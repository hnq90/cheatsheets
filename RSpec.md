**GEMFILE**	group :development do     gem 'rspec-rails'	end	group :test do     gem 'rspec'     gem 'webrat'	end**Install RSpec**	rails generate rspec:installOptional:	gem install autotest	gem install autotest-rails-pure	gem install autotest-fsevent	gem install autotest-growl**Listing 5.16** Additions to .autotest needed to run integration tests with Autotest on OS X.	Autotest.add_hook :initialize do |autotest| autotest.add_mapping(/ˆspec\/requests\/.*_spec\.rb$/) do		autotest.files_matching(/ˆspec\/requests\/.*_spec\.rb$/)	end end**Model settings:**	validates :email, :presence => true,		:format => { :with => email_regex },		:uniqueness => { :case_sensitive => false}**Migration to add email uniqueness:**	add_index :users, :email, :unique => true**spec/models/user_spec.rb**	describe User do		before(:each) do @attr = {	      :name => "Example User",	      :email => "user@example.com",	      :password => "foobar",	      :password_confirmation => "foobar"		}		end				it "should create a new instance given valid attributes" do 			User.create!(@attr)		end			it "should require a name" do		    no_name_user = User.new(@attr.merge(:name => ""))		    no_name_user.should_not be_valid		end		it "should reject names that are too long" do			long_name = "a" * 51		    long_name_user = User.new(@attr.merge(:name => long_name))		    long_name_user.should_not be_valid		end		it "should accept valid email addresses" do			addresses = %w[user@foo.com THE_USER@foo.bar.org first.last@foo.jp] addresses.each do |address|		      valid_email_user = User.new(@attr.merge(:email => address))		      valid_email_user.should be_valid			end 		end		it "should reject invalid email addresses" do			addresses = %w[user@foo,com user_at_foo.org example.user@foo.] addresses.each do |address|		      invalid_email_user = User.new(@attr.merge(:email => address))		      invalid_email_user.should_not be_valid			end 		end				it "should reject duplicate email addresses" do		    # Put a user with given email address into the database.		    User.create!(@attr)		    user_with_duplicate_email = User.new(@attr)		    user_with_duplicate_email.should_not be_valid		end		it "should reject email addresses identical up to case" do		    upcased_email = @attr[:email].upcase		    User.create!(@attr.merge(:email => upcased_email))		    user_with_duplicate_email = User.new(@attr)		    user_with_duplicate_email.should_not be_valid		end				describe "password validations" do			it "should require a password" do				User.new(@attr.merge(:password => "", :password_confirmation => "")).should_not be_valid			end			it "should require a matching password confirmation" do				User.new(@attr.merge(:password_confirmation => "invalid")).should_not be_valid				end			it "should reject short passwords" do				short = "a" * 5				hash = @attr.merge(:password => short, :password_confirmation => short) 				User.new(hash).should_not be_valid			end			it "should reject long passwords" do				long = "a" * 41				hash = @attr.merge(:password => long, :password_confirmation => long) 				User.new(hash).should_not be_valid			end		end		describe "password encryption" do			before(:each) do				@user = User.create!(@attr)			end			it "should have an encrypted password attribute" do 				@user.should respond_to(:encrypted_password)			end			it "should set the encrypted password" do			      @user.encrypted_password.should_not be_blank			end		end		end**Model validations for PASSWORD**		attr_accessible :name, :email, :password, :password_confirmation		# Automatically create the virtual attribute 'password_confirmation'.	validates :password, :presence => true,		:confirmation => true,		:length => { :within => 6..40 }	**Add `encrypted_password` to `User` model**	rails generate migration add_password_to_users encrypted_password:string	**Run specific RSpec test**	rspec spec/models/user_spec.rb \	> -e "should have an encrypted password attribute"	**`before_save` callback to save `encrypted_password` in model `User`**	before_save :encrypt_password	private		def encrypt_password			self.encrypted_password = encrypt(password)		end			def encrypt(string)			Digest::SHA2.hexdigest(string)		end	**Authenticate logins**	describe "authenticate method" do		it "should return nil on email/password mismatch" do			wrong_password_user = User.authenticate(@attr[:email], "wrongpass")			wrong_password_user.should be_nil		end				it "should return nil for an email address with no user" do			nonexistent_user = User.authenticate("bar@foo.com", @attr[:password])			nonexistent_user.should be_nil		end		it "should return the user on email/password match" do 			matching_user = User.authenticate(@attr[:email], @attr[:password])			matching_user.should == @user		end 			end	**Class method to find users**	def self.authenticate(email, submitted_password)		user = find_by_email(email)		return nil if user.nil?		return user if user.has_password?(submitted_password)	end	Install `factory_girl_rails`	gem 'factory_girl_rails', '1.0'	`spec/factories.rb`	# Using the symbol ':user', we get Factory Girl to simulate the User model.	Factory.define :user do |user|		￼user.name "Michael Lee"		user.email 'mcle@gmail.com""		user.password "foobar"		user.password_confirmation" "foobar"	end`spec/controllers/users_controller_spec.rb`	describe "GET 'show'" do		before(:each) do			@user = Factory(:user)		end				it "should be successful" do 			get :show, :id => @user 			response.should be_success		end				it "should find the right user" do 			get :show, :id => @user 			assigns(:user).should == @user		end 	end**Model test**		expect {    	AppceleratorAPI.import(AppceleratorAPI.fetch["response"]["touchBase"])	}.to change(DoContactList, :count).by(1)	expect {	  my_model.do_something	}.to change { my_model.field }.from("old value").to("expected value")**Test images:**	it "should have a profile image" do		get :show, :id => @user		response.should have_selector("h1>img", :class => "gravatar")	end`gravatar_image_tag`		<%= gravatar_image_tag 'example@railstutorial.org' %>	**A Gravatar helper**		def gravatar_for(user, options = { :size => 50 }) 		gravatar_image_tag(user.email.downcase, :alt => user.name,			:class => 'gravatar',			:gravatar => options)	end